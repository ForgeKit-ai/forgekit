import { exec } from 'child_process';
import { promisify } from 'util';
import fs from 'fs';
import path from 'path';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const tar = require('tar');
import axios from 'axios';
import FormData from 'form-data';
import { ensureLoggedIn } from '../src/auth.js';
import { generateDockerfile } from '../src/utils/dockerfile.js';

const asyncExec = promisify(exec);

export const command = 'deploy';
export const describe = 'Build, bundle, and deploy to ForgeKit hosting';
export const builder = {
  'build-dir': {
    type: 'string',
    describe: 'Directory containing build output',
  },
};

function readForgeConfig() {
  const cfgPath = path.join(process.cwd(), 'forgekit.json');
  if (fs.existsSync(cfgPath)) {
    try {
      return JSON.parse(fs.readFileSync(cfgPath, 'utf-8'));
    } catch {}
  }
  return {};
}

function detectBuildDir(argv) {
  if (argv.buildDir) return argv.buildDir;
  const cfg = readForgeConfig();
  if (cfg.buildDir) return cfg.buildDir;
  const map = {
    'react-vite': 'dist',
    'vue-vite': 'dist',
    'sveltekit': 'build',
    'nextjs': '.next',
    'astro': 'dist',
    'blazor': 'dist',
    'godot': 'dist',
  };
  if (cfg.frontend && map[cfg.frontend]) return map[cfg.frontend];
  const guesses = ['dist', 'build', '.next', 'out'];
  return guesses.find(d => fs.existsSync(d)) || 'dist';
}

export const handler = async (argv = {}) => {
  const token = await ensureLoggedIn();
  if (!token) {
    console.error('‚ùå Unable to authenticate. Deployment canceled.');
    return;
  }

  const bundlePath = path.join(process.cwd(), 'bundle.tar.gz');
  const buildDir = detectBuildDir(argv);
  
  let dockerfileGeneratedAndStackName = null; // To store stack name for logging
  const dockerfilePath = path.join(process.cwd(), 'Dockerfile');

  try {
    // Dockerfile generation logic
    if (!fs.existsSync(dockerfilePath)) {
      const forgeConfig = readForgeConfig();
      let stackForDockerfile;

      if (forgeConfig && Object.keys(forgeConfig).length > 0) {
        if (forgeConfig.stack) {
          stackForDockerfile = forgeConfig.stack;
        } else if (forgeConfig.frontend) {
          stackForDockerfile = forgeConfig.frontend;
          if (forgeConfig.backend) {
            stackForDockerfile += ` + ${forgeConfig.backend}`;
          }
        } else if (forgeConfig.backend) {
          stackForDockerfile = forgeConfig.backend;
        }
      }

      if (!stackForDockerfile) {
        throw new Error('‚ùå forgekit.json is missing, malformed, or does not contain stack information. Cannot auto-generate Dockerfile.');
      }

      const dockerfileContent = generateDockerfile(stackForDockerfile);
      if (dockerfileContent) {
        fs.writeFileSync(dockerfilePath, dockerfileContent);
        dockerfileGeneratedAndStackName = stackForDockerfile; // Store for logging
      } else {
        // Log a warning if Dockerfile couldn't be generated for a supposedly supported stack
        console.warn(`‚ö†Ô∏è Could not generate Dockerfile for stack: ${stackForDockerfile}. This stack might not be supported for auto-generation or an internal issue occurred.`);
      }
    }

    const useYarn = fs.existsSync('yarn.lock');
    const buildCmd = useYarn ? 'yarn build' : 'npm run build';
    console.log('üèóÔ∏è Building project...');
    await asyncExec(buildCmd);

    if (!fs.existsSync(buildDir)) {
      console.error(`‚ùå Build directory '${buildDir}' not found. Did you run the build step?`);
      return;
    }

    console.log(`üì¶ Bundling ${buildDir}/ into bundle.tar.gz...`);
    await tar.c({ gzip: true, file: bundlePath }, [buildDir]);

    if (dockerfileGeneratedAndStackName) {
      console.log(`üõ†Ô∏è Generating Dockerfile for stack: ${dockerfileGeneratedAndStackName}`);
    }

    console.log('üöÄ Uploading bundle...');
    const form = new FormData();
    form.append('bundle', fs.createReadStream(bundlePath));
    const deployUrl = process.env.FORGEKIT_DEPLOY_URL || 'http://178.156.171.10:3001/deploy_cli';
    const res = await axios.post(deployUrl, form, {
      headers: { ...form.getHeaders(), Authorization: `Bearer ${token}` },
    });
    const url = res.data && res.data.url;
    console.log(`Deployed at: ${url}`);
  } catch (err) {
    if (err.response && err.response.status === 401) {
      console.error('‚ùå Deployment failed: unauthorized. Try running `forge login` again.');
    } else {
      console.error('‚ùå Deployment failed:', err.message || err);
    }
  } finally {
    try {
      fs.unlinkSync(bundlePath);
    } catch {}
    // Delete Dockerfile if it was generated by this command
    if (dockerfileGeneratedAndStackName && fs.existsSync(dockerfilePath)) {
      try {
        fs.unlinkSync(dockerfilePath);
        // console.log('üóëÔ∏è Auto-generated Dockerfile removed.'); // Optional: for verbose logging
      } catch (err) {
        console.warn(`‚ö†Ô∏è Could not remove auto-generated Dockerfile: ${err.message}`);
      }
    }
  }
};
